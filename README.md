# JSXソースコード完全解説

## Part 1. JSXの設計 (30%)

### JSXの誕生

- JavaScriptの発展
- altJSの誕生
- JSXの設計思想
- JSXプログラムを実行する
- セルフホスティング

## インストール

- JSXコンパイラの入手
- JSXプログラムの実行

### 基本的な構文

- クラスとメンバー
- 式と文
- モジュール
- ジェネレータ
- JSXdoc

### 総称的プログラミング

- 型とオブジェクト
- クラステンプレート
- 関数テンプレート
- ダックタイピング (型消去)

### 開発とデバッグ

- ユニットテスト
- デバッグ機能
- ソースマップ
- プロファイラ
- リリースビルド
- ソースコード圧縮
- grunt-jsx

## Part 2. JSXの実装 (70%)

### Part 2-1. コンパイラの実装 (25%)

#### コンパイラの構造

- コンパイラの概要
- コンパイラの動作環境
- 動作プラットフォームの抽象化

#### 構文解析

- parser.jsxの概要
- 字句解析器
- 再帰下降構文解析
- 抽象構文木の構造
- クラスとメンバー
- 文と式

#### 意味解析

- analysis.jsxの概要
- 型の解決
- 型推論
- テンプレートの実体化

#### コード変換

- 最適化
- 識別子の圧縮

#### コード生成

- jsemitter.jsxの概要
- クラス定義の生成
- 式の生成
- 文の生成
- 識別子のマッピング

#### JavaScriptランタイム

- プロトタイプによる継承の実現
- エントリポイントの呼び出し
- テストケースの呼び出し

### Part 2-2. 最適化 (30%)

#### オプティマイザの構造

- オプティマイザと最適化コマンド
- リンク時最適化 (lto)
	- 静的リンクと動的リンク
- 最適化ログ

#### インライン展開 (inline)

- 最適化戦略
- 呼び出し先の決定 (determine-callee)
- 展開条件
- inlineとreturn-if

#### 定数畳み込み (fold-const)

- 定数伝搬と定数畳み込み
- 式の畳み込み
- 数式と等価判定
- 関数呼び出し

#### デッドコード削除 (dce)

- デッドコード削除とは
- 副作用のない式
- 未使用変数
- 無効な代入
- 分岐先の確定

#### 非BOX化 (unbox)

- 非BOX化とは
- 非BOX化条件
- ローカル変数の非BOX化

#### その他の最適化

- no-assert/no-log/no-debug
- 局所共通部分式除去 (lcse)
- Array最適化 (array-length)
- 非クラス化 (unclassify/staticize)
- 末尾再帰の最適化 (tail-rec)

#### 最適化の効果

- releaseオプション
- 個別の最適化コマンド

### Part 2-3. CPS変換 (15%)

#### CPS変換とは

- なぜCPS変換が必要なのか
- try-catchとCPS変換

#### ジェネレータ

- ジェネレータとは
- JavaScript 1.8のジェネレータ
- ECMAScript6のジェネレータ
- JSXのジェネレータ
- 型の扱いと糖衣構文

#### 非同期処理

- コールバックの問題点
- 非同期処理とコルーチン
- C#のasync/await
- プロミスベースのQ
- ES6の非同期処理

#### CPS変換の実装戦略

- C#の戦略
- google-traceurの戦略
- JSXの戦略(1. ナイーブな実装)
- JSXの戦略(2. より高速な実装)

#### トランスフォーマーの構造

- 式の変換
- 文の変換
- コードの合成
- Returnの変換

